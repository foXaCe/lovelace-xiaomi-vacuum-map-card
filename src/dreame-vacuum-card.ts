/* eslint-disable @typescript-eslint/no-explicit-any */
import { css, CSSResultGroup, html, LitElement, PropertyValues, svg, SVGTemplateResult, TemplateResult } from "lit";
import { customElement, property, state } from "lit/decorators";
import { forwardHaptic, LovelaceCard, LovelaceCardEditor } from "custom-card-helpers";

import "./editor";
import type {
    LovelaceDomEvent,
    PredefinedPointConfig,
    ReplacedKey,
    RoomConfig,
    RoomConfigEventData,
    XiaomiVacuumMapCardConfig,
} from "./types/types";
import {
    ActionType,
    CalibrationPoint,
    CardPresetConfig,
    MapExtractorRoom,
    PointType,
    PredefinedZoneConfig,
    TranslatableString,
    VariablesStorage,
} from "./types/types";
import {
    CARD_CUSTOM_ELEMENT_NAME,
    CARD_VERSION,
    DISCONNECTED_IMAGE,
    DISCONNECTION_TIME,
    EDITOR_CUSTOM_ELEMENT_NAME,
    EMPTY_MAP_MODE,
    EVENT_AUTOGENERATED_CONFIG,
    EVENT_AUTOGENERATED_CONFIG_GET,
    EVENT_LOVELACE_DOM,
    EVENT_LOVELACE_DOM_DETAIL,
    EVENT_ROOM_CONFIG,
    EVENT_ROOM_CONFIG_GET,
    EVENT_SELECTION_CHANGED,
    EVENT_SERVICE_CALL,
    EVENT_SERVICE_CALL_GET,
} from "./const";
import { localize, localizeWithHass } from "./localize/localize";
import PinchZoom from "./pinch-zoom";
import "./pinch-zoom";
import { ManualRectangle } from "./model/map_objects/manual-rectangle";
import { Context } from "./model/map_objects/context";
import { ManualPoint } from "./model/map_objects/manual-point";
import { ManualPath } from "./model/map_objects/manual-path";
import {
    checkIfEntitiesChanged,
    conditional,
    delay,
    getMousePosition,
    getWatchedEntities,
    hasConfigOrAnyEntityChanged,
    stopEvent,
} from "./utils";
import { PredefinedPoint } from "./model/map_objects/predefined-point";
import { PredefinedMultiRectangle } from "./model/map_objects/predefined-multi-rectangle";
import { Room } from "./model/map_objects/room";
import { Obstacle } from "./model/map_objects/obstacle";
import { Furniture } from "./model/map_objects/furniture";
import { areAllEntitiesDefined, isOldConfig, validateConfig } from "./config-validators";
import { MapMode } from "./model/map_mode/map-mode";
import { SelectionType } from "./model/map_mode/selection-type";
import { RepeatsType } from "./model/map_mode/repeats-type";
import { PlatformGenerator } from "./model/generators/platform-generator";
import { CoordinatesConverter } from "./model/map_objects/coordinates-converter";
import { MapObject } from "./model/map_objects/map-object";
import { MousePosition } from "./model/map_objects/mouse-position";
import { HomeAssistantFixed } from "./types/fixes";
import "./polyfills/objectEntries";
import "./polyfills/objectFromEntries";

import "./components/status-header";
import "./components/cleaning-mode-chip";
import "./components/tab-selector";
import "./components/action-buttons";
import "./components/cleaning-progress-bar";
import "./components/robot-animation";

/** Palette Dreame par défaut, indexée par color_index 0-3 */
const DEFAULT_ROOM_PALETTE: Record<number, number[]> = {
    0: [121, 170, 255],
    1: [255, 211, 38],
    2: [141, 210, 255],
    3: [150, 217, 141],
};

const windowWithCards = window as unknown as Window & { customCards: unknown[] };
windowWithCards.customCards = windowWithCards.customCards || [];
windowWithCards.customCards.push({
    type: CARD_CUSTOM_ELEMENT_NAME,
    name: "Vacuum Map Card",
    description: localize("common.description"),
});

@customElement(CARD_CUSTOM_ELEMENT_NAME)
export class XiaomiVacuumMapCard extends LitElement {
    @state() private oldConfig = false;
    @state() private config!: XiaomiVacuumMapCardConfig;
    @state() private presetIndex!: number;
    @state() private realScale!: number;
    @state() private realImageWidth!: number;
    @state() private realImageHeight!: number;
    @state() private mapScale!: number;
    @state() private mapX!: number;
    @state() private mapY!: number;
    @state() public repeats = 1;
    @state() private selectedMode = 0;
    @state() private activeTab: "room" | "all" | "zone" = "all";
    @state() private mapLocked = false;
    @state() private configErrors: string[] = [];
    @state() private connected = false;
    @state() public internalVariables = {};
    private currentPreset!: CardPresetConfig;
    private watchedEntities: string[] = [];
    private selectedManualRectangles: ManualRectangle[] = [];
    private selectedManualPoint?: ManualPoint;
    private selectedManualPath: ManualPath = new ManualPath([], this._getContext());
    private selectedPredefinedRectangles: PredefinedMultiRectangle[] = [];
    private selectedRooms: Room[] = [];
    private selectedPredefinedPoints: PredefinedPoint[] = [];
    private selectablePredefinedRectangles: PredefinedMultiRectangle[] = [];
    private selectableRooms: Room[] = [];
    private selectablePredefinedPoints: PredefinedPoint[] = [];
    private coordinatesConverter?: CoordinatesConverter;
    private entitiesToManuallyUpdate: string[] = [];
    private modes: MapMode[] = [];
    private shouldHandleMouseUp!: boolean;
    private lastHassUpdate!: Date;
    public isInEditor = false;
    private lastValidMapUrl?: string;
    private _overlayDirty = false;
    private _cachedContext: Context | undefined;
    private _pickCanvas: HTMLCanvasElement | null = null;
    private _pickCtx: CanvasRenderingContext2D | null = null;
    private _lastPickCacheKey?: string;
    private _pickLoadingKey?: string;
    private _stateSensorId: string | null | undefined = undefined;
    private _stateSensorEntityKey: string | undefined = undefined;

    constructor() {
        super();
        this._handleAutogeneratedConfigGet = this._handleAutogeneratedConfigGet.bind(this);
        this._handleRoomsConfigGet = this._handleRoomsConfigGet.bind(this);
        this._handleServiceCallGet = this._handleServiceCallGet.bind(this);
        this._handleLovelaceDomEvent = this._handleLovelaceDomEvent.bind(this);
    }

    @property({ attribute: false }) public _hass!: HomeAssistantFixed;

    public get hass(): HomeAssistantFixed {
        return this._hass;
    }

    public set hass(hass: HomeAssistantFixed) {
        const firstHass = !this._hass && hass;
        this._hass = hass;
        this.lastHassUpdate = new Date();
        if (firstHass) {
            this._firstHass();
        }
    }

    public static async getConfigElement(): Promise<LovelaceCardEditor> {
        return document.createElement(EDITOR_CUSTOM_ELEMENT_NAME);
    }

    public static getStubConfig(hass: HomeAssistantFixed): XiaomiVacuumMapCardConfig | undefined {
        const entities = Object.keys(hass.states);
        const cameras = entities
            .filter((e) => ["camera", "image"].includes(e.substring(0, e.indexOf("."))))
            .filter((e) => hass?.states[e].attributes["calibration_points"]);
        const vacuums = entities.filter((e) => e.substring(0, e.indexOf(".")) === "vacuum");
        if (cameras.length === 0 || vacuums.length === 0) {
            return undefined;
        }
        return {
            type: "custom:" + CARD_CUSTOM_ELEMENT_NAME,
            map_source: {
                camera: cameras[0],
            },
            calibration_source: {
                camera: true,
            },
            entity: vacuums[0],
            vacuum_platform: PlatformGenerator.TASSHACK_DREAME_VACUUM_PLATFORM,
        };
    }

    public setConfig(config: XiaomiVacuumMapCardConfig): void {
        if (!config) {
            throw new Error(this._localize("common.invalid_configuration"));
        }
        this.config = config;
        if (isOldConfig(config)) {
            this.oldConfig = true;
            return;
        }
        this.configErrors = validateConfig(this.config);
        if (this.configErrors.length > 0) {
            return;
        }
        this.watchedEntities = getWatchedEntities(this.config);
        this._setPresetIndex(0, false, true);
        this.requestUpdate("config");
    }

    public getCardSize(): number {
        return 12;
    }

    public getLayoutOptions() {
        return {
            grid_columns: 4,
            grid_min_columns: 2,
            grid_rows: 4,
            grid_min_rows: 3,
        };
    }

    connectedCallback(): void {
        super.connectedCallback();
        if (this._isInEditor()) {
            window.addEventListener(EVENT_AUTOGENERATED_CONFIG_GET, this._handleAutogeneratedConfigGet);
            window.addEventListener(EVENT_ROOM_CONFIG_GET, this._handleRoomsConfigGet);
            window.addEventListener(EVENT_SERVICE_CALL_GET, this._handleServiceCallGet);
            this.isInEditor = true;
        }
        document.addEventListener(EVENT_LOVELACE_DOM, this._handleLovelaceDomEvent);
        this.connected = true;
        this._updateElements();
        this._initializeRooms();
        delay(100).then(() => this.requestUpdate());
    }

    disconnectedCallback(): void {
        super.disconnectedCallback();
        if (this._isInEditor()) {
            window.removeEventListener(EVENT_AUTOGENERATED_CONFIG_GET, this._handleAutogeneratedConfigGet);
            window.removeEventListener(EVENT_ROOM_CONFIG_GET, this._handleRoomsConfigGet);
            window.removeEventListener(EVENT_SERVICE_CALL_GET, this._handleServiceCallGet);
        }
        document.removeEventListener(EVENT_LOVELACE_DOM, this._handleLovelaceDomEvent);
        this.connected = false;
    }

    protected shouldUpdate(changedProps: PropertyValues): boolean {
        if (!this.config) {
            return false;
        }
        return hasConfigOrAnyEntityChanged(this.watchedEntities, changedProps, false, this.hass);
    }

    private _resolveStateSensor(entityId: string): string | null {
        if (this._stateSensorId !== undefined && this._stateSensorEntityKey === entityId) {
            return this._stateSensorId;
        }
        this._stateSensorEntityKey = entityId;
        const deviceId = this.hass?.entities?.[entityId]?.device_id;
        if (!deviceId) {
            this._stateSensorId = null;
            return null;
        }
        for (const [eid, entry] of Object.entries(this.hass.entities)) {
            if (entry.device_id !== deviceId || !eid.startsWith("sensor.")) continue;
            if ((entry as any).translation_key === "state" || eid.endsWith("_state")) {
                this._stateSensorId = eid;
                return eid;
            }
        }
        this._stateSensorId = null;
        return null;
    }

    protected render(): TemplateResult | void {
        if (this.oldConfig) {
            return this._showOldConfig();
        }
        if (this.configErrors.length > 0) {
            return this._showConfigErrors(this.configErrors);
        }
        const invalidEntities = areAllEntitiesDefined(this.watchedEntities, this.hass);
        if (invalidEntities.length > 0) {
            return this._showInvalidEntities(invalidEntities);
        }

        const preset = this._getCurrentPreset();

        const stateSensorId = this._resolveStateSensor(preset.entity);
        const robotState = stateSensorId ? (this.hass.states[stateSensorId]?.state ?? "") : "";
        if (stateSensorId && !this.watchedEntities.includes(stateSensorId)) {
            this.watchedEntities.push(stateSensorId);
        }

        this._updateCalibration(preset);

        // Compute charger position as percentage of map image
        let chargerXPct = -1;
        let chargerYPct = -1;
        if (this.coordinatesConverter?.calibrated && preset.map_source?.camera) {
            const camState = this.hass.states[preset.map_source.camera];
            const chargerPos = camState?.attributes?.charger_position;
            if (chargerPos && chargerPos.x != null && chargerPos.y != null) {
                const mapCoords = this.coordinatesConverter.vacuumToMap(chargerPos.x, chargerPos.y);
                const img = this.shadowRoot?.querySelector("#map-image") as HTMLImageElement | null;
                const natW = img?.naturalWidth;
                const natH = img?.naturalHeight;
                if (natW && natH) {
                    chargerXPct = (mapCoords[0] / natW) * 100;
                    chargerYPct = (mapCoords[1] / natH) * 100;
                }
            }
        }

        const mapSrc = this._getMapSrc(preset);
        const platformsWithDefaultCalibration = PlatformGenerator.getPlatformsWithDefaultCalibration();
        const platformHasDefaultCalibration = platformsWithDefaultCalibration.includes(
            PlatformGenerator.getPlatformName(preset.vacuum_platform)
        );
        const validCalibration =
            (!!this.coordinatesConverter && this.coordinatesConverter.calibrated) || platformHasDefaultCalibration;

        const hasSelection = this._hasActiveSelection();

        const mapZoomerContent = html`
            <div
                id="map-zoomer-content"
                style="
                 margin-top: ${(preset.map_source.crop?.top ?? 0) * -1}px;
                 margin-bottom: ${(preset.map_source.crop?.bottom ?? 0) * -1}px;
                 margin-left: ${(preset.map_source.crop?.left ?? 0) * -1}px;
                 margin-right: ${(preset.map_source.crop?.right ?? 0) * -1}px;"
            >
                <img
                    id="map-image"
                    alt="camera_image"
                    crossorigin="anonymous"
                    class="${this.mapScale * this.realScale > 1 ? "zoomed" : ""}"
                    src="${mapSrc}"
                    style="pointer-events: none;"
                    @load="${() => {
                        this._calculateBasicScale();
                        this._buildPickCanvas();
                    }}"
                />

                <canvas id="room-selection-overlay"></canvas>

                <div id="map-image-overlay">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        version="2.0"
                        id="svg-wrapper"
                        class="${this.activeTab === "room" ? "room-mode" : ""}"
                        width="100%"
                        height="100%"
                        @mousedown="${(e: MouseEvent): void => this._mouseDown(e)}"
                        @mousemove="${(e: MouseEvent): void => this._mouseMove(e)}"
                        @mouseup="${(e: PointerEvent): void => this._mouseUp(e)}"
                        @click="${(e: MouseEvent): void => this._handleMapClick(e)}"
                    >
                        ${validCalibration ? this._drawSelection() : null}
                        ${validCalibration ? this._drawRooms() : null}
                    </svg>
                </div>
                <dreame-robot-animation
                    .robotState=${robotState}
                    .chargerX=${chargerXPct}
                    .chargerY=${chargerYPct}
                ></dreame-robot-animation>
            </div>
        `;

        return html`
            <ha-card style="--map-scale: ${this.mapScale}; --real-scale: ${this.realScale};">
                <div class="map-wrapper">
                    <dreame-status-header
                        .hass=${this.hass}
                        .entityId=${preset.entity}
                        .showTitle=${this.config.show_title ?? false}
                    ></dreame-status-header>
                    <div class="map-container">
                        <pinch-zoom
                            min-scale="0.5"
                            id="map-zoomer"
                            @change="${this._calculateScale}"
                            two-finger-pan="${preset.two_finger_pan}"
                            locked="${this.mapLocked}"
                            no-default-pan="${this.mapLocked || preset.two_finger_pan}"
                            style="touch-action: none;"
                        >
                            ${mapZoomerContent}
                        </pinch-zoom>
                    </div>
                    <div id="map-zoomer-overlay">
                        <div class="map-zoom-icons">
                            ${this.activeTab === "zone"
                                ? html`
                                      <ha-icon
                                          icon="mdi:plus"
                                          class="icon-on-map clickable ripple"
                                          @click="${() => this._addRectangle()}"
                                      ></ha-icon>
                                  `
                                : null}
                            ${this.activeTab === "zone" || this.activeTab === "room"
                                ? html`
                                      <div
                                          class="icon-on-map clickable ripple cycle-counter"
                                          @click="${() => {
                                              const maxRepeats = this._getCurrentMode()?.maxRepeats ?? 3;
                                              this.repeats = (this.repeats % maxRepeats) + 1;
                                              forwardHaptic("selection");
                                              this.requestUpdate();
                                          }}"
                                      >
                                          x${this.repeats}
                                      </div>
                                  `
                                : null}
                            <ha-icon
                                icon="mdi:image-filter-center-focus"
                                class="icon-on-map clickable ripple"
                                @click="${this._restoreMap}"
                            ></ha-icon>
                        </div>
                    </div>
                </div>
                ${conditional(!validCalibration, () => this._showInvalidCalibrationWarning())}
                <dreame-cleaning-mode-chip .hass=${this.hass} .entityId=${preset.entity}></dreame-cleaning-mode-chip>
                <dreame-tab-selector
                    .activeTab=${this.activeTab}
                    .language=${this.hass?.locale?.language ?? ""}
                    @tab-changed=${(e: CustomEvent) => this._handleTabChange(e.detail.tab)}
                ></dreame-tab-selector>
                <dreame-cleaning-progress-bar
                    .hass=${this.hass}
                    .entityId=${preset.entity}
                ></dreame-cleaning-progress-bar>
                <dreame-action-buttons
                    .hass=${this.hass}
                    .entityId=${preset.entity}
                    .activeTab=${this.activeTab}
                    .hasSelection=${hasSelection}
                    .selectionCount=${this.selectedRooms.length + this.selectedPredefinedRectangles.length}
                    @action-run=${() => this._run(false)}
                    @action-cancel=${() => this._clearSelection()}
                ></dreame-action-buttons>
            </ha-card>
        `;
    }

    private _hasActiveSelection(): boolean {
        return (
            this.selectedManualRectangles.length > 0 ||
            this.selectedRooms.length > 0 ||
            this.selectedPredefinedRectangles.length > 0 ||
            this.selectedPredefinedPoints.length > 0 ||
            !!this.selectedManualPoint
        );
    }

    private _handleTabChange(tab: "room" | "all" | "zone"): void {
        this.activeTab = tab;
        this._clearSelection();
        const modes = this.modes;
        switch (tab) {
            case "room": {
                const roomIdx = modes.findIndex((m) => m.selectionType === SelectionType.ROOM);
                if (roomIdx >= 0) this._setCurrentMode(roomIdx);
                break;
            }
            case "zone": {
                const zoneIdx = modes.findIndex((m) => m.selectionType === SelectionType.MANUAL_RECTANGLE);
                if (zoneIdx >= 0) {
                    this._setCurrentMode(zoneIdx);
                    // Ajouter automatiquement un rectangle pour commencer à dessiner
                    setTimeout(() => this._addRectangle(), 100);
                }
                break;
            }
            case "all":
                // Mode "Toutes" : aucune interaction sur la carte, juste visualisation
                break;
        }
        this._overlayDirty = true;
        this.requestUpdate();
    }

    private _clearSelection(): void {
        this.selectedManualRectangles = [];
        this.selectedManualPoint = undefined;
        this.selectedManualPath = new ManualPath([], this._getContext());
        this.selectedPredefinedRectangles.forEach((r) => ((r as any).selected = false));
        this.selectedPredefinedRectangles = [];
        this.selectedRooms.forEach((r) => ((r as any)._selected = false));
        this.selectedRooms = [];
        this.selectedPredefinedPoints.forEach((p) => ((p as any).selected = false));
        this.selectedPredefinedPoints = [];
        this._overlayDirty = true;
        this.requestUpdate();
    }

    protected updated(changedProperties: PropertyValues): void {
        const oldHass = changedProperties.get("_hass") as HomeAssistantFixed | undefined;
        const changed =
            oldHass && this.hass && checkIfEntitiesChanged(this.entitiesToManuallyUpdate, oldHass, this.hass);
        this._updateElements(changed);

        if (this._overlayDirty) {
            this._overlayDirty = false;
            this._updateRoomSelectionOverlay();
        }
    }

    public _getCurrentPreset(): CardPresetConfig {
        return this.currentPreset;
    }

    private _getCalibration(config: CardPresetConfig): CalibrationPoint[] | undefined {
        if (config.calibration_source?.identity) {
            return [
                { map: { x: 0, y: 0 }, vacuum: { x: 0, y: 0 } },
                { map: { x: 1, y: 0 }, vacuum: { x: 1, y: 0 } },
                { map: { x: 0, y: 1 }, vacuum: { x: 0, y: 1 } },
            ];
        }
        if (
            config.calibration_source?.calibration_points &&
            [3, 4].includes(config.calibration_source.calibration_points.length)
        ) {
            return config.calibration_source.calibration_points;
        }
        if (!this.hass) {
            return undefined;
        }
        if (config.calibration_source?.entity && !config.calibration_source?.attribute) {
            try {
                const state = this.hass.states[config.calibration_source.entity]?.state;
                if (!state || state === "unavailable" || state === "unknown") return undefined;
                return JSON.parse(state);
            } catch {
                return undefined;
            }
        }
        if (config.calibration_source?.entity && config.calibration_source?.attribute) {
            return this.hass.states[config.calibration_source.entity]?.attributes[config.calibration_source.attribute];
        }
        if (config.calibration_source?.camera) {
            return this.hass.states[config.map_source?.camera ?? ""]?.attributes["calibration_points"];
        }
        if (config.calibration_source?.platform) {
            return PlatformGenerator.getCalibration(config.calibration_source.platform);
        }
        const platformCalibration = PlatformGenerator.getCalibration(config.vacuum_platform);
        if (platformCalibration) {
            return platformCalibration;
        }
        return undefined;
    }

    private _firstHass(): void {
        if (this.configErrors.length === 0 && !this.oldConfig) {
            this._setPresetIndex(0, false, true);
        }
    }

    private _setPresetIndex(index: number, user = false, force = false): void {
        if (index === this.presetIndex && !force) {
            return;
        }
        const config = this.config;
        if (!this.mapLocked) this._getPinchZoom()?.setTransform({ scale: 1, x: 0, y: 0, allowChangeEvent: true });
        if (user) {
            forwardHaptic("selection");
        }
        this.mapLocked = config?.map_locked ?? false;
        this.selectedMode = 0;
        this.realScale = 1;
        this.mapScale = 1;
        this.mapX = 0;
        this.mapY = 0;
        this._cachedContext = undefined;
        if (this.hass) this._updateCalibration(config);
        this.modes = this._getModes(config);

        this.presetIndex = index;
        this.currentPreset = config;
        this.internalVariables = this._getInternalVariables(config);

        this._setPreset(config);
        setTimeout(() => this.requestUpdate(), 100);
        this._setCurrentMode(0, false);
        this._selectionChanged();
    }

    private _getInternalVariables(config: CardPresetConfig): VariablesStorage {
        return {
            ...(PlatformGenerator.getVariables(config.vacuum_platform) ?? {}),
            ...(config.internal_variables ?? {}),
        };
    }

    private _getModes(config: CardPresetConfig) {
        const vacuumPlatform = PlatformGenerator.getPlatformName(config.vacuum_platform);
        return (
            (config.map_modes?.length ?? -1) === -1 || vacuumPlatform.startsWith("Setup")
                ? PlatformGenerator.generateDefaultModes(vacuumPlatform)
                : (config.map_modes ?? [EMPTY_MAP_MODE])
        ).map((m) => new MapMode(vacuumPlatform, m, this.config.language));
    }

    private _setPreset(config: CardPresetConfig): void {
        this.currentPreset = config;
        this.watchedEntities = getWatchedEntities({ type: "", ...config });
    }

    private _updateCalibration(config: CardPresetConfig): void {
        this.coordinatesConverter = undefined;
        const calibrationPoints = this._getCalibration(config);
        this.coordinatesConverter = new CoordinatesConverter(calibrationPoints);
    }

    private _getMapSrc(config: CardPresetConfig): string {
        if (config.map_source.camera) {
            if (
                this.connected &&
                this.lastHassUpdate &&
                this.lastHassUpdate.getTime() + DISCONNECTION_TIME >= new Date().getTime()
            ) {
                const url = this.hass.hassUrl(this.hass.states[config.map_source.camera].attributes.entity_picture);
                const lastUpdated = this.hass.states[config.map_source.camera]?.last_updated ?? "";
                const fullUrl = `${url}&v=${lastUpdated}`;
                // Store last valid map URL for cache
                this.lastValidMapUrl = fullUrl;
                return fullUrl;
            }
            // Return cached map instead of disconnected image
            if (this.lastValidMapUrl) {
                return this.lastValidMapUrl;
            }
            return DISCONNECTED_IMAGE;
        }
        if (config.map_source.image) {
            return `${config.map_source.image}`;
        }
        return DISCONNECTED_IMAGE;
    }

    private _getContext(): Context {
        if (!this._cachedContext) {
            this._cachedContext = new Context(
                () => this.mapScale,
                () => this.realScale,
                (event) => this._getMousePosition(event),
                () => this.requestUpdate(),
                () => this._selectionChanged(),
                () => this.coordinatesConverter,
                () => this.selectedManualRectangles,
                () => this.selectedPredefinedRectangles,
                () => this.selectedRooms,
                () => this.selectedPredefinedPoints,
                () => this._getCurrentMode()?.coordinatesRounding ?? false,
                () => this._getCurrentMode()?.coordinatesToMetersDivider ?? 1,
                () => this._getCurrentMode()?.maxSelections ?? 0,
                (property) => this._getCssProperty(property),
                () => this._runImmediately(),
                (string) => this._localize(string),
                (entity) => this._hass.states[entity].state,
                (entity) => this._hass.callService("homeassistant", "toggle", { entity_id: entity }),
                () => this._getCurrentMode(),
                () => this._activateRoomMode(),
                () => this.activeTab
            );
        }
        return this._cachedContext;
    }

    private _getMousePosition(event: MouseEvent | TouchEvent): MousePosition {
        return getMousePosition(event, this._getSvgWrapper(), this.mapScale);
    }

    private _setCurrentMode(newModeIndex: number, manual = true): void {
        const newMode = this.modes[newModeIndex];
        this.selectedManualRectangles = [];
        this.selectedManualPoint = undefined;
        this.selectedManualPath.clear();
        this.selectedPredefinedRectangles = [];
        // Réinitialiser l'état _selected de toutes les pièces avant de vider le tableau
        this.selectableRooms.forEach((room) => {
            (room as any)._selected = false;
        });
        this.selectedRooms = [];
        this.selectedPredefinedPoints = [];
        this.selectablePredefinedRectangles = [];
        // Ne pas vider selectableRooms - les pièces doivent rester visibles en permanence
        // this.selectableRooms = [];
        this.selectablePredefinedPoints = [];

        switch (newMode?.selectionType) {
            case SelectionType.PREDEFINED_RECTANGLE:
                const zonesFromEntities = PredefinedMultiRectangle.getFromEntities(newMode, this.hass, () =>
                    this._getContext()
                );
                const manualZones = newMode.predefinedSelections
                    .map((ps) => ps as PredefinedZoneConfig)
                    .filter((pzc) => typeof pzc.zones !== "string")
                    .map((pzc) => new PredefinedMultiRectangle(pzc, this._getContext()));
                this.selectablePredefinedRectangles = zonesFromEntities.concat(manualZones);
                this.selectedPredefinedRectangles = this.selectablePredefinedRectangles.filter((s) => s.selected);
                this.entitiesToManuallyUpdate = newMode.predefinedSelections
                    .filter((s) => s.state_entity)
                    .map((s) => s.state_entity as string);
                break;
            case SelectionType.ROOM:
                // Ne recréer les pièces que si elles n'existent pas déjà
                if (this.selectableRooms.length === 0) {
                    this.selectableRooms = newMode.predefinedSelections.map(
                        (ps) => new Room(ps as RoomConfig, this._getContext())
                    );
                }
                this.selectedRooms = this.selectableRooms.filter((s) => s.selected);
                this.entitiesToManuallyUpdate = newMode.predefinedSelections
                    .filter((s) => s.state_entity)
                    .map((s) => s.state_entity as string);
                break;
            case SelectionType.PREDEFINED_POINT:
                const pointsFromEntities = PredefinedPoint.getFromEntities(newMode, this.hass, () =>
                    this._getContext()
                );
                const manualPoints = newMode.predefinedSelections
                    .map((ps) => ps as PredefinedPointConfig)
                    .filter((ppc) => typeof ppc.position !== "string")
                    .map((ppc) => new PredefinedPoint(ppc, this._getContext()));
                this.selectablePredefinedPoints = pointsFromEntities.concat(manualPoints);
                this.selectedPredefinedPoints = this.selectablePredefinedPoints.filter((s) => s.selected);
                this.entitiesToManuallyUpdate = newMode.predefinedSelections
                    .filter((s) => s.state_entity)
                    .map((s) => s.state_entity as string);
                break;
        }
        if (this.selectedMode != newModeIndex && manual) forwardHaptic("selection");
        this.selectedMode = newModeIndex;
        this._selectionChanged();
    }

    public _getCurrentMode(): MapMode | undefined {
        return this.modes[this.selectedMode];
    }

    public _getSelection(mode: MapMode | undefined): { selection: unknown[]; variables: VariablesStorage } {
        if (!mode) {
            return { selection: [], variables: {} };
        }
        const repeats = mode.repeatsType === RepeatsType.INTERNAL ? this.repeats : null;
        let selection: unknown[] = [];
        let variables: VariablesStorage = {};
        const variablesExtractor = (mos: Array<MapObject | undefined>): VariablesStorage => ({
            ...(mos[0]?.variables ?? {}),
            variables: mos.map((r) => r?.variables ?? {}),
        });
        switch (mode.selectionType) {
            case SelectionType.MANUAL_RECTANGLE:
                selection = this.selectedManualRectangles.map((r) => r.toVacuum(repeats));
                variables = variablesExtractor(this.selectedManualRectangles);
                break;
            case SelectionType.PREDEFINED_RECTANGLE:
                selection = this.selectedPredefinedRectangles
                    .map((r) => r.toVacuum(repeats))
                    .reduce((a, v) => a.concat(v), [] as unknown[]);
                variables = this.selectedPredefinedRectangles[0]?.variables ?? {};
                variables = variablesExtractor(this.selectedPredefinedRectangles);
                break;
            case SelectionType.ROOM:
                const selectedRooms = this.selectedRooms
                    .map((r) => r.toVacuum())
                    .map((r) => XiaomiVacuumMapCard.adjustRoomId(r, mode));
                selection = [...selectedRooms, ...(repeats && selectedRooms.length > 0 ? [repeats] : [])];
                variables = this.selectedRooms[0]?.variables ?? {};
                variables = variablesExtractor(this.selectedRooms);
                break;
            case SelectionType.MANUAL_PATH:
                selection = this.selectedManualPath.toVacuum(repeats);
                variables = this.selectedManualPath.variables ?? {};
                variables = variablesExtractor([this.selectedManualPath]);
                break;
            case SelectionType.MANUAL_POINT:
                selection = this.selectedManualPoint?.toVacuum(repeats) ?? [];
                variables = variablesExtractor([this.selectedManualPoint]);
                break;
            case SelectionType.PREDEFINED_POINT:
                selection = this.selectedPredefinedPoints
                    .map((p) => p.toVacuum(repeats))
                    .reduce((a, v) => a.concat(v), [] as unknown[]);
                variables = variablesExtractor(this.selectedPredefinedPoints);
                break;
        }
        if (mode.repeatsType === RepeatsType.REPEAT) {
            selection = Array(this.repeats)
                .fill(0)
                .flatMap(() => selection);
        }
        return { selection, variables };
    }

    private async _runImmediately(): Promise<boolean> {
        if (this._getCurrentMode()?.runImmediately ?? false) {
            await this._run(false);
            return true;
        }
        return false;
    }

    private _selectionChanged(): void {
        const currentMode = this._getCurrentMode();
        const { selection } = this._getSelection(currentMode);

        if (this.isInEditor) {
            const event = new Event(EVENT_SELECTION_CHANGED);
            (event as any).selection = selection ?? "[]";
            window.dispatchEvent(event);
        }

        // Marquer l'overlay comme devant être redessiné (sera fait dans updated() après le rendu Lit)
        this._overlayDirty = true;
        this.requestUpdate();
    }

    private _isInEditor(): boolean {
        function isInEditor(e: Element): boolean {
            return (
                (e.parentElement?.tagName?.toLowerCase() === "hui-card" &&
                    "preview" in (e.parentElement?.attributes ?? [])) ||
                (e.parentElement?.tagName?.toLowerCase() === "hui-section" &&
                    "preview" in (e.parentElement?.attributes ?? [])) ||
                e.parentElement?.tagName?.toLowerCase() === "hui-card-preview" ||
                (e.parentElement != null && isInEditor(e.parentElement)) ||
                (e.parentNode?.toString() == "[object ShadowRoot]" && isInEditor((e.getRootNode() as ShadowRoot).host))
            );
        }
        return isInEditor(this);
    }

    private async _handleAutogeneratedConfigGet(): Promise<void> {
        const event = new Event(EVENT_AUTOGENERATED_CONFIG);
        (event as any).presetConfig = {
            ...this.config,
            map_modes: this._getModes(this.config).map((m) => m.toMapModeConfig()),
        };
        window.dispatchEvent(event);
    }

    private _handleRoomsConfigGet(): void {
        const event = new Event(EVENT_ROOM_CONFIG);
        (event as any).roomConfig = this._getRoomsConfig();
        window.dispatchEvent(event);
    }

    private async _handleServiceCallGet(): Promise<void> {
        const currentPreset = this._getCurrentPreset();
        const currentMode = this._getCurrentMode();
        const { selection, variables } = this._getSelection(currentMode);
        if ((selection as any[]).length === 0 || !currentMode) {
            forwardHaptic("failure");
        } else {
            const serviceCall = await currentMode.getServiceCall(
                this.hass,
                currentPreset.entity,
                selection,
                this.repeats,
                { ...this.internalVariables, ...variables }
            );
            const event = new Event(EVENT_SERVICE_CALL);
            (event as any).serviceCall = JSON.stringify(serviceCall, null, 2);
            window.dispatchEvent(event);
        }
    }

    private async _handleLovelaceDomEvent(e: Event): Promise<void> {
        const lovelaceEvent = e as LovelaceDomEvent;
        if (
            EVENT_LOVELACE_DOM_DETAIL in lovelaceEvent.detail &&
            "action_handler_id" in lovelaceEvent.detail[EVENT_LOVELACE_DOM_DETAIL] &&
            lovelaceEvent.detail[EVENT_LOVELACE_DOM_DETAIL]["action_handler_id"] ===
                (this.config.action_handler_id ?? "this")
        ) {
            const details = lovelaceEvent.detail[EVENT_LOVELACE_DOM_DETAIL];
            if (details["action"] === undefined) return;
            const action = details["action"] as ActionType;
            const data = details["data"];
            const currentMode = this._getCurrentMode();
            switch (action) {
                case ActionType.CLEANING_START:
                    await this._run(false);
                    break;
                case ActionType.INTERNAL_VARIABLE_SET:
                    this._setInternalVariable(data["variable"], data["value"]);
                    break;
                case ActionType.MAP_MODE_NEXT:
                    this._setCurrentMode((this.selectedMode + 1) % this.modes.length, false);
                    break;
                case ActionType.MAP_MODE_PREVIOUS:
                    this._setCurrentMode((this.selectedMode - 1 + this.modes.length) % this.modes.length, false);
                    break;
                case ActionType.MAP_MODE_SET:
                    this._setCurrentMode(data["index"] % this.modes.length, false);
                    break;
                case ActionType.REPEATS_DECREMENT:
                    if (currentMode) {
                        this.repeats = ((this.repeats + currentMode.maxRepeats - 2) % currentMode.maxRepeats) + 1;
                    }
                    break;
                case ActionType.REPEATS_INCREMENT:
                    if (currentMode) {
                        this.repeats = (this.repeats % currentMode.maxRepeats) + 1;
                    }
                    break;
                case ActionType.REPEATS_SET:
                    if (currentMode) {
                        this.repeats = ((data["value"] + currentMode.maxRepeats - 1) % currentMode.maxRepeats) + 1;
                    }
                    break;
                case ActionType.SELECTION_CLEAR:
                    this._setCurrentMode(this.selectedMode);
                    break;
            }
        }
    }

    private _setInternalVariable(variable: string, value: ReplacedKey) {
        const newValues = { ...this.internalVariables };
        newValues[variable] = value;
        this.internalVariables = newValues;
        this.requestUpdate();
    }

    private static _polygonArea(outline: number[][]): number {
        let area = 0;
        const n = outline.length;
        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            area += outline[i][0] * outline[j][1];
            area -= outline[j][0] * outline[i][1];
        }
        return Math.abs(area) / 2;
    }

    private _getRoomsConfig(): RoomConfigEventData | undefined {
        const config = this._getCurrentPreset();
        const rooms = this.hass.states[config.map_source?.camera ?? ""]?.attributes["rooms"] as Record<
            string,
            MapExtractorRoom
        >;
        const roomsConfig = new Array<RoomConfig>();

        if (rooms) {
            const mode = this.modes.filter((m) => m.selectionType === SelectionType.ROOM).reverse()[0];
            const modeIndex = mode ? this.modes.indexOf(mode) : -1;

            for (const room_id in rooms) {
                if (!Object.prototype.hasOwnProperty.call(rooms, room_id)) continue;
                const room = rooms[room_id];

                if (!room.outline && !room.x0 && !room.y0 && !room.x1 && !room.y1) continue;
                if (room.visibility === "Hidden") continue;

                const outline = room.outline ?? [
                    [room.x0, room.y0],
                    [room.x1, room.y0],
                    [room.x1, room.y1],
                    [room.x0, room.y1],
                ];

                let roomColor: number[] | undefined = room.color ?? undefined;
                if (!roomColor && room.color_index != null) {
                    roomColor = DEFAULT_ROOM_PALETTE[room.color_index];
                }

                roomsConfig.push({
                    id: room_id,
                    icon: undefined,
                    label: undefined,
                    outline: outline,
                    color: roomColor,
                    color_index: room.color_index ?? undefined,
                } as RoomConfig);
            }

            return { modeIndex: modeIndex, rooms: roomsConfig };
        }
        return undefined;
    }

    private static adjustRoomId(roomId: string | number, config: MapMode): string | number {
        if (config.idType === "number") {
            const roomIdAsNumber = +roomId;
            return isNaN(roomIdAsNumber) ? roomId : roomIdAsNumber;
        }
        return roomId;
    }

    private async _run(debug: boolean): Promise<void> {
        const currentPreset = this._getCurrentPreset();
        const currentMode = this._getCurrentMode();
        const { selection, variables } = this._getSelection(currentMode);
        if ((selection as any[]).length === 0 || !currentMode) {
            forwardHaptic("failure");
        } else {
            const repeats = this.repeats;
            const serviceCall = await currentMode.getServiceCall(this.hass, currentPreset.entity, selection, repeats, {
                ...this.internalVariables,
                ...variables,
            });
            if (debug || (this.config.debug ?? false)) {
                const message = JSON.stringify(serviceCall, null, 2);
                window.alert(message);
                forwardHaptic("success");
            } else {
                this.hass
                    .callService(serviceCall.domain, serviceCall.service, serviceCall.serviceData, serviceCall.target)
                    .then(
                        () => {
                            forwardHaptic("success");
                        },
                        () => {
                            forwardHaptic("failure");
                        }
                    );
            }
        }
        if (currentPreset.clean_selection_on_start ?? true) {
            this._setCurrentMode(this.selectedMode);
        }
        this._selectionChanged();
    }

    private _updateElements(somethingChanged = false): void {
        delay(10).then(() => this._calculateBasicScale());

        if (!somethingChanged) {
            return;
        }

        const update = () => {
            this._setCurrentMode(this.selectedMode);
            this.requestUpdate();
        };

        switch (this._getCurrentMode()?.selectionType) {
            case SelectionType.PREDEFINED_RECTANGLE:
                if (this.selectablePredefinedRectangles.filter((p) => p.isDynamic()).length > 0) update();
                break;
            case SelectionType.ROOM:
                if (this.selectedRooms.filter((p) => p.isDynamic()).length > 0) update();
                break;
            case SelectionType.PREDEFINED_POINT:
                if (this.selectablePredefinedPoints.filter((p) => p.isDynamic()).length > 0) update();
                break;
        }
    }

    private _handleMapClick(e: MouseEvent): void {
        if (this.activeTab !== "room") return;

        const room = this._hitTestRoom(e);
        if (room) {
            e.stopPropagation();
            room.toggleFromHitTest();
        }
    }

    private _drawRooms(): SVGTemplateResult | null {
        if (this.selectableRooms.length === 0) return null;
        // En mode Pièce, seuls les labels sont rendus — l'overlay canvas gère le visuel
        // Les polygones SVG de l'API sont décalés et inutilisables
        return svg`${this.selectableRooms.map((r) => r.renderLabelOnly())}`;
    }

    private _drawSelection(): SVGTemplateResult | null {
        // En mode "all", aucune sélection sur la carte (comme l'app Dreame)
        if (this.activeTab === "all") {
            return null;
        }
        switch (this._getCurrentMode()?.selectionType) {
            case SelectionType.MANUAL_RECTANGLE:
                return svg`${this.selectedManualRectangles.map((r) => r.render())}`;
            case SelectionType.PREDEFINED_RECTANGLE:
                return svg`${this.selectablePredefinedRectangles.map((r) => r.render())}`;
            case SelectionType.ROOM:
                // Les pièces sont déjà affichées par _drawRooms(), ne pas les afficher deux fois
                return null;
            case SelectionType.MANUAL_PATH:
                return svg`${this.selectedManualPath?.render()}`;
            case SelectionType.MANUAL_POINT:
                return svg`${this.selectedManualPoint?.render()}`;
            case SelectionType.PREDEFINED_POINT:
                return svg`${this.selectablePredefinedPoints.map((p) => p.render())}`;
            default:
                return null;
        }
    }

    private _addRectangle(): void {
        const preset = this._getCurrentPreset();
        const currentMode = this._getCurrentMode();
        const marginTop = preset.map_source.crop?.top ?? 0;
        const marginBottom = preset.map_source.crop?.bottom ?? 0;
        const marginLeft = preset.map_source.crop?.left ?? 0;
        const marginRight = preset.map_source.crop?.right ?? 0;
        this._calculateBasicScale();
        if (!currentMode || this.selectedManualRectangles.length >= currentMode.maxSelections) {
            forwardHaptic("failure");
            return;
        }
        const actualHeight = this.realImageHeight * this.realScale - marginTop - marginBottom;
        const actualWidth = this.realImageWidth * this.realScale - marginLeft - marginRight;
        const name = (this.selectedManualRectangles.length + 1).toString();
        const x = (actualWidth / 3 + marginLeft - this.mapX) / this.mapScale;
        const y = (actualHeight / 3 + marginTop - this.mapY) / this.mapScale;
        const width = actualWidth / 3 / this.mapScale;
        const height = actualHeight / 3 / this.mapScale;
        this.selectedManualRectangles.push(new ManualRectangle(x, y, width, height, name, this._getContext()));
        this._selectionChanged();
        forwardHaptic("selection");
        this.requestUpdate();
    }

    private _mouseDown(event: PointerEvent | MouseEvent | TouchEvent): void {
        if (event instanceof MouseEvent && event.button != 0) {
            return;
        }
        this.shouldHandleMouseUp = true;
    }

    private _mouseMove(event: MouseEvent | TouchEvent): void {
        if ((<Element>event.target).classList.contains("draggable")) {
            return;
        }
        this.selectedManualRectangles.filter((r) => r.isSelected()).forEach((r) => r.externalDrag(event));
        this.shouldHandleMouseUp = false;
    }

    private _mouseUp(event: PointerEvent | MouseEvent | TouchEvent): void {
        // En mode "all", aucune interaction sur la carte (comme l'app Dreame)
        if (this.activeTab === "all") {
            this.shouldHandleMouseUp = false;
            return;
        }

        const target = event.target as SVGElement;
        // Pour les éléments SVG, className est un SVGAnimatedString, pas une string
        const classNameObj = target?.className;
        const classNames =
            (typeof classNameObj === "string" ? classNameObj : classNameObj?.baseVal) ||
            target?.getAttribute?.("class") ||
            "";
        const isRoomPolygon = classNames.includes("room-polygon");

        // Si le click provient d'un polygone de pièce, ne rien faire ici
        // Le handler du polygone va gérer le click
        if (isRoomPolygon) {
            this.shouldHandleMouseUp = false;
            return;
        }

        const currentMode = this._getCurrentMode();
        if (!(event instanceof MouseEvent && event.button != 0) && this.shouldHandleMouseUp && currentMode) {
            const { x, y } = getMousePosition(event, this._getSvgWrapper(), 1);
            switch (currentMode.selectionType) {
                case SelectionType.MANUAL_PATH:
                    forwardHaptic("selection");
                    this.selectedManualPath.addPoint(x, y);
                    this._selectionChanged();
                    stopEvent(event);
                    this.requestUpdate();
                    break;
                case SelectionType.MANUAL_POINT:
                    forwardHaptic("selection");
                    this.selectedManualPoint = new ManualPoint(x, y, this._getContext());
                    this._selectionChanged();
                    stopEvent(event);
                    this.requestUpdate();
                    break;
                default:
                    // Ne pas bloquer l'événement pour les autres modes (ROOM, etc.)
                    // L'événement doit se propager aux polygones des pièces
                    break;
            }
        }
        this.shouldHandleMouseUp = false;
    }

    private _restoreMap(): void {
        const zoomerContent = this._getMapZoomerContent();
        zoomerContent.style.transitionDuration = this._getCssProperty("--map-card-internal-transitions-duration");
        this._getPinchZoom().setTransform({ scale: 1, x: 0, y: 0, allowChangeEvent: true });
        this.mapScale = 1;
        forwardHaptic("selection");
        delay(300).then(() => (zoomerContent.style.transitionDuration = "0s"));
    }

    private _initializeRoomsRetries = 0;

    private _initializeRooms(): void {
        if (!this.modes || this.modes.length === 0) {
            if (this._initializeRoomsRetries >= 20) return;
            this._initializeRoomsRetries++;
            delay(500).then(() => this._initializeRooms());
            return;
        }
        this._initializeRoomsRetries = 0;

        const roomMode = this.modes.find(
            (m) => m.config.template === "vacuum_clean_segment" || m.selectionType === SelectionType.ROOM
        );

        if (!roomMode) return;

        if (roomMode.predefinedSelections && roomMode.predefinedSelections.length > 0) {
            this.selectableRooms = roomMode.predefinedSelections.map(
                (s) => new Room(s as RoomConfig, this._getContext())
            );
            this.requestUpdate();
            return;
        }

        const roomsConfig = this._getRoomsConfig();

        if (roomsConfig && roomsConfig.rooms.length > 0) {
            if (!roomMode.predefinedSelections || roomMode.predefinedSelections.length === 0) {
                roomMode.predefinedSelections = roomsConfig.rooms;
            }
            this.selectableRooms = roomsConfig.rooms.map((s) => new Room(s as RoomConfig, this._getContext()));
            this.requestUpdate();
        }
    }

    private _activateRoomMode(): void {
        // Cherche le mode vacuum_clean_segment ou un mode avec ROOM selection type
        let roomMode = this.modes.findIndex((m) => m.config.template === "vacuum_clean_segment");

        // Si vacuum_clean_segment n'existe pas, chercher un mode avec ROOM
        if (roomMode === -1) {
            roomMode = this.modes.findIndex((m) => m.selectionType === SelectionType.ROOM);
        }

        if (roomMode !== -1) {
            this._setCurrentMode(roomMode, true);
            forwardHaptic("selection");
        }
    }

    private _getCssProperty(property: string): string {
        return getComputedStyle(this._getMapImage()).getPropertyValue(property);
    }

    private _calculateBasicScale(): void {
        const mapImage = this._getMapImage();
        if (mapImage && mapImage.naturalWidth > 0) {
            this.realImageWidth = mapImage.naturalWidth;
            this.realImageHeight = mapImage.naturalHeight;
            this.realScale = mapImage.width / mapImage.naturalWidth;
        }
    }

    /**
     * Pick buffer : canvas dont le canal bleu encode l'ID de segment de chaque pièce.
     * Source principale : segment_map de l'API (pixel-perfect depuis pixel_type).
     * Fallback : polygones de l'API dessinés avec bleu = segment ID.
     */
    private _buildPickCanvas(): void {
        const config = this._getCurrentPreset();
        const cameraEntity = config.map_source?.camera;
        if (!cameraEntity || !this.hass?.states[cameraEntity]) return;

        const entityState = this.hass.states[cameraEntity];
        const cacheKey = entityState.last_updated ?? entityState.last_changed ?? "";

        // Déjà prêt pour cette version
        if (cacheKey === this._lastPickCacheKey && this._pickCanvas) return;
        // Déjà en cours de chargement async
        if (cacheKey === this._pickLoadingKey) return;

        const segmentMap = entityState.attributes["segment_map"] as string | undefined;
        if (segmentMap) {
            this._loadSegmentMap(segmentMap, cacheKey);
        } else {
            this._buildPickCanvasFromPolygons(cacheKey);
        }
    }

    /**
     * Charge le segment_map base64 depuis l'API (PNG, canal bleu = segment ID).
     */
    private _loadSegmentMap(b64: string, cacheKey: string): void {
        this._pickLoadingKey = cacheKey;
        const img = new Image();
        img.onload = () => {
            this._pickLoadingKey = undefined;
            const mapImage = this._getMapImage();
            if (!mapImage || mapImage.naturalWidth === 0) return;

            // Garder la taille ORIGINALE du segment_map pour le hit-test
            // Le segment_map encode les IDs dans les pixels, on ne doit pas étirer
            const w = img.naturalWidth;
            const h = img.naturalHeight;
            const canvas = document.createElement("canvas");
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext("2d", { willReadFrequently: true });
            if (!ctx) return;

            ctx.drawImage(img, 0, 0);

            this._pickCanvas = canvas;
            this._pickCtx = ctx;
            this._lastPickCacheKey = cacheKey;
        };
        img.onerror = () => {
            this._pickLoadingKey = undefined;
            console.warn("[PickCanvas] segment_map failed, fallback polygons");
            this._buildPickCanvasFromPolygons(cacheKey);
        };
        img.src = `data:image/png;base64,${b64}`;
    }

    /**
     * Fallback : construit le pick canvas depuis les polygones de l'API.
     * Canal bleu = parseInt(roomId), masqué par l'image réelle.
     */
    private _buildPickCanvasFromPolygons(cacheKey: string): void {
        const mapImage = this._getMapImage();
        if (!mapImage || mapImage.naturalWidth === 0) return;
        if (!this.coordinatesConverter) return;

        const roomPolygons = this._getApiRoomPolygons();
        if (roomPolygons.size === 0) return;

        const w = mapImage.naturalWidth;
        const h = mapImage.naturalHeight;
        const canvas = document.createElement("canvas");
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        if (!ctx) return;

        ctx.clearRect(0, 0, w, h);

        // Trier par aire décroissante (painter's algorithm)
        const entries = [...roomPolygons.entries()];
        entries.sort((a, b) => XiaomiVacuumMapCard._polygonArea(b[1]) - XiaomiVacuumMapCard._polygonArea(a[1]));

        for (const [roomId, poly] of entries) {
            const id = parseInt(roomId) || 0;
            if (id === 0 || id > 255) continue;

            ctx.fillStyle = `rgb(0,0,${id})`;
            ctx.beginPath();
            ctx.moveTo(poly[0][0], poly[0][1]);
            for (let i = 1; i < poly.length; i++) {
                ctx.lineTo(poly[i][0], poly[i][1]);
            }
            ctx.closePath();
            ctx.fill();
        }

        // Masquer avec l'image réelle : supprimer les pixels hors-pièce
        try {
            const tmpCanvas = document.createElement("canvas");
            tmpCanvas.width = w;
            tmpCanvas.height = h;
            const tmpCtx = tmpCanvas.getContext("2d");
            if (tmpCtx) {
                tmpCtx.drawImage(mapImage, 0, 0);
                const mapPixels = tmpCtx.getImageData(0, 0, w, h).data;
                const pickImgData = ctx.getImageData(0, 0, w, h);
                const pd = pickImgData.data;
                for (let i = 0; i < w * h; i++) {
                    const off = i * 4;
                    const mr = mapPixels[off],
                        mg = mapPixels[off + 1],
                        mb = mapPixels[off + 2];
                    if (mr + mg + mb < 80 || Math.max(mr, mg, mb) - Math.min(mr, mg, mb) < 25) {
                        pd[off] = 0;
                        pd[off + 1] = 0;
                        pd[off + 2] = 0;
                        pd[off + 3] = 0;
                    }
                }
                ctx.putImageData(pickImgData, 0, 0);
            }
        } catch (e) {
            console.warn("[PickCanvas] Cannot mask (CORS?):", e);
        }

        this._pickCanvas = canvas;
        this._pickCtx = ctx;
        this._lastPickCacheKey = cacheKey;
    }

    /**
     * Récupère les polygones des pièces depuis l'API (pour l'overlay visuel).
     */
    private _apiRoomPolygonsCache: Map<string, PointType[]> | null = null;
    private _apiRoomPolygonsCacheKey?: string;

    private _getApiRoomPolygons(): Map<string, PointType[]> {
        if (!this.coordinatesConverter) return new Map();

        const config = this._getCurrentPreset();
        const cameraEntity = config.map_source?.camera;
        if (!cameraEntity || !this.hass?.states[cameraEntity]) return new Map();

        const entityState = this.hass.states[cameraEntity];
        const cacheKey = entityState.last_updated ?? entityState.last_changed ?? "";

        if (this._apiRoomPolygonsCache && this._apiRoomPolygonsCacheKey === cacheKey) {
            return this._apiRoomPolygonsCache;
        }

        const rooms = entityState.attributes["rooms"] as Record<string, MapExtractorRoom> | undefined;
        if (!rooms) return new Map();

        const result = new Map<string, PointType[]>();

        for (const roomId in rooms) {
            if (!Object.prototype.hasOwnProperty.call(rooms, roomId)) continue;
            const room = rooms[roomId];
            if (room.visibility === "Hidden") continue;

            const outline: PointType[] | null = room.outline
                ? (room.outline as PointType[])
                : room.x0 != null && room.y0 != null && room.x1 != null && room.y1 != null
                  ? [
                        [room.x0, room.y0],
                        [room.x1, room.y0],
                        [room.x1, room.y1],
                        [room.x0, room.y1],
                    ]
                  : null;

            if (!outline || outline.length < 3) continue;

            const imagePoly = outline.map((p) => this.coordinatesConverter!.vacuumToMap(p[0], p[1]));
            result.set(String(roomId), imagePoly);
        }

        this._apiRoomPolygonsCache = result;
        this._apiRoomPolygonsCacheKey = cacheKey;
        return result;
    }

    /**
     * Overlay style Dreame : toute la carte assombrie sauf les pièces sélectionnées.
     * Utilise le pick buffer (canal bleu = room ID) pour un cutout pixel-perfect.
     */
    private _updateRoomSelectionOverlay(): void {
        const overlayCanvas = this.shadowRoot?.getElementById("room-selection-overlay") as HTMLCanvasElement | null;
        if (!overlayCanvas) return;

        const ctx = overlayCanvas.getContext("2d");
        if (!ctx) return;

        // Hors mode pièce → pas d'overlay
        if (this.activeTab !== "room") {
            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            return;
        }

        this._buildPickCanvas();
        if (!this._pickCtx || !this._pickCanvas) {
            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            return;
        }

        const mapImg = this.shadowRoot?.getElementById("map-image") as HTMLImageElement | null;
        if (!mapImg || mapImg.naturalWidth === 0) return;

        const outW = mapImg.naturalWidth;
        const outH = mapImg.naturalHeight;

        if (overlayCanvas.width !== outW || overlayCanvas.height !== outH) {
            overlayCanvas.width = outW;
            overlayCanvas.height = outH;
        }

        const pickW = this._pickCanvas.width;
        const pickH = this._pickCanvas.height;

        const selectedRoomIds = new Set<number>();
        for (const room of this.selectedRooms) {
            selectedRoomIds.add(Number(room.toVacuum()));
        }
        const hasSelection = selectedRoomIds.size > 0;

        const pickData = this._pickCtx.getImageData(0, 0, pickW, pickH).data;

        // Construire l'overlay à la résolution du segment_map (petite) puis upscaler avec lissage.
        // Cela produit des bords lisses au lieu de marches d'escalier.
        const smallCanvas = document.createElement("canvas");
        smallCanvas.width = pickW;
        smallCanvas.height = pickH;
        const smallCtx = smallCanvas.getContext("2d");
        if (!smallCtx) return;
        const smallImg = smallCtx.createImageData(pickW, pickH);
        const sd = smallImg.data;

        for (let y = 0; y < pickH; y++) {
            for (let x = 0; x < pickW; x++) {
                const pi = (y * pickW + x) * 4;
                const roomId = pickData[pi + 2];

                if (hasSelection && roomId > 0 && selectedRoomIds.has(roomId)) {
                    // Pièce sélectionnée → transparent (pas de dim)
                    continue;
                }

                // Tout le reste → noir semi-transparent
                sd[pi + 3] = 100;
            }
        }

        smallCtx.putImageData(smallImg, 0, 0);

        // Upscaler avec lissage du navigateur → bords doux
        ctx.clearRect(0, 0, outW, outH);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
        ctx.drawImage(smallCanvas, 0, 0, outW, outH);
    }

    /**
     * Hit-test pixel-perfect : canal bleu du pick buffer = room ID directement.
     */
    private _hitTestRoom(event: MouseEvent): Room | null {
        if (this.selectableRooms.length === 0) return null;

        this._buildPickCanvas();
        if (!this._pickCtx || !this._pickCanvas) return null;

        const mapImage = this._getMapImage();
        if (!mapImage) return null;

        const rect = mapImage.getBoundingClientRect();
        const relX = (event.clientX - rect.left) / rect.width;
        const relY = (event.clientY - rect.top) / rect.height;
        const x = Math.round(relX * this._pickCanvas.width);
        const y = Math.round(relY * this._pickCanvas.height);

        if (x < 0 || y < 0 || x >= this._pickCanvas.width || y >= this._pickCanvas.height) return null;

        const pixel = this._pickCtx.getImageData(x, y, 1, 1).data;
        const roomId = pixel[2];
        if (roomId === 0) return null;

        return this.selectableRooms.find((r) => String(r.toVacuum()) === String(roomId)) ?? null;
    }

    private _calculateScale(): void {
        const pinchZoom = this._getPinchZoom();
        if (!pinchZoom) return;
        this.mapScale = pinchZoom.scale;
        this.mapX = pinchZoom.x;
        this.mapY = pinchZoom.y;
    }

    private _getPinchZoom(): PinchZoom {
        return this.shadowRoot?.getElementById("map-zoomer") as PinchZoom;
    }

    private _getMapImage(): HTMLImageElement {
        return this.shadowRoot?.getElementById("map-image") as HTMLImageElement;
    }

    private _getMapZoomerContent(): HTMLElement {
        return this.shadowRoot?.getElementById("map-zoomer-content") as HTMLElement;
    }

    private _getSvgWrapper(): SVGGraphicsElement {
        return this.shadowRoot?.querySelector("#svg-wrapper") as SVGGraphicsElement;
    }

    private _showConfigErrors(errors: string[]): TemplateResult {
        errors.forEach((e) => console.error(e));
        const errorCard = document.createElement("hui-error-card") as LovelaceCard;
        try {
            errorCard.setConfig({
                type: "error",
                error: errors[0],
                origConfig: this.config,
            });
            return html` ${errorCard} `;
        } catch {
            return html` <pre style="padding: 10px; background-color: red;">${errors[0]}</pre> `;
        }
    }

    private _showOldConfig(): TemplateResult {
        return html`
            <hui-warning>
                <h1>Xiaomi Vacuum Map Card ${CARD_VERSION}</h1>
                <p>${this._localize("common.old_configuration")}</p>
                <p>
                    <a href="https://github.com/foXaCe/dreame-vacuum-card#migrating-from-v1xx" target="_blank"
                        >${this._localize("common.old_configuration_migration_link")}</a
                    >
                </p>
            </hui-warning>
        `;
    }

    private _showInvalidEntities(entities: string[]): TemplateResult {
        return html`
            <hui-warning>
                <h1>${this._localize("validation.invalid_entities")}</h1>
                <ul>
                    ${entities.map(
                        (e) =>
                            html` <li>
                                <pre>${e}</pre>
                            </li>`
                    )}
                </ul>
            </hui-warning>
        `;
    }

    private _showInvalidCalibrationWarning(): TemplateResult {
        return html` <hui-warning>${this._localize("validation.invalid_calibration")}</hui-warning> `;
    }

    private _localize(ts: TranslatableString): string {
        return localizeWithHass(ts, this.hass, this.config);
    }

    static get styles(): CSSResultGroup {
        return css`
            ha-card {
                overflow: hidden;
                display: flow-root;
                container-type: inline-size;
                container-name: vacuum-card;
                --map-card-internal-primary-color: var(--map-card-primary-color, var(--slider-color));
                --map-card-internal-primary-text-color: var(--map-card-primary-text-color, var(--primary-text-color));
                --map-card-internal-secondary-color: var(--map-card-secondary-color, var(--slider-secondary-color));
                --map-card-internal-secondary-text-color: var(
                    --map-card-secondary-text-color,
                    var(--text-light-primary-color)
                );
                --map-card-internal-tertiary-color: var(--map-card-tertiary-color, var(--secondary-background-color));
                --map-card-internal-tertiary-text-color: var(--map-card-tertiary-text-color, var(--primary-text-color));
                --map-card-internal-disabled-text-color: var(
                    --map-card-disabled-text-color,
                    var(--disabled-text-color)
                );
                --map-card-internal-zoomer-background: var(
                    --map-card-zoomer-background,
                    var(--map-card-internal-tertiary-color)
                );
                --map-card-internal-ripple-color: var(--map-card-ripple-color, #7a7f87);
                --map-card-internal-big-radius: var(--map-card-big-radius, 25px);
                --map-card-internal-small-radius: var(--map-card-small-radius, 18px);
                --map-card-internal-predefined-point-icon-wrapper-size: var(
                    --map-card-predefined-point-icon-wrapper-size,
                    36px
                );
                --map-card-internal-predefined-point-icon-size: var(--map-card-predefined-point-icon-size, 24px);
                --map-card-internal-predefined-point-icon-color: var(
                    --map-card-predefined-point-icon-color,
                    var(--map-card-internal-secondary-text-color)
                );
                --map-card-internal-predefined-point-icon-color-selected: var(
                    --map-card-predefined-point-icon-color-selected,
                    var(--map-card-internal-primary-text-color)
                );
                --map-card-internal-predefined-point-icon-background-color: var(
                    --map-card-predefined-point-icon-background-color,
                    var(--map-card-internal-secondary-color)
                );
                --map-card-internal-predefined-point-icon-background-color-selected: var(
                    --map-card-predefined-point-icon-background-color-selected,
                    var(--map-card-internal-primary-color)
                );
                --map-card-internal-predefined-point-label-color: var(
                    --map-card-predefined-point-label-color,
                    var(--map-card-internal-secondary-text-color)
                );
                --map-card-internal-predefined-point-label-color-selected: var(
                    --map-card-predefined-point-label-color-selected,
                    var(--map-card-internal-primary-text-color)
                );
                --map-card-internal-predefined-point-label-font-size: var(
                    --map-card-predefined-point-label-font-size,
                    12px
                );
                --map-card-internal-manual-point-radius: var(--map-card-manual-point-radius, 5px);
                --map-card-internal-manual-point-line-color: var(--map-card-manual-point-line-color, yellow);
                --map-card-internal-manual-point-fill-color: var(--map-card-manual-point-fill-color, transparent);
                --map-card-internal-manual-point-line-width: var(--map-card-manual-point-line-width, 1px);
                --map-card-internal-manual-path-point-radius: var(--map-card-manual-path-point-radius, 5px);
                --map-card-internal-manual-path-point-line-color: var(--map-card-manual-path-point-line-color, yellow);
                --map-card-internal-manual-path-point-fill-color: var(
                    --map-card-manual-path-point-fill-color,
                    transparent
                );
                --map-card-internal-manual-path-point-line-width: var(--map-card-manual-path-point-line-width, 1px);
                --map-card-internal-manual-path-line-color: var(--map-card-manual-path-line-color, yellow);
                --map-card-internal-manual-path-line-width: var(--map-card-manual-path-line-width, 1px);
                --map-card-internal-predefined-rectangle-line-width: var(
                    --map-card-predefined-rectangle-line-width,
                    1px
                );
                --map-card-internal-predefined-rectangle-line-color: var(
                    --map-card-predefined-rectangle-line-color,
                    white
                );
                --map-card-internal-predefined-rectangle-fill-color: var(
                    --map-card-predefined-rectangle-fill-color,
                    transparent
                );
                --map-card-internal-predefined-rectangle-line-color-selected: var(
                    --map-card-predefined-rectangle-line-color-selected,
                    white
                );
                --map-card-internal-predefined-rectangle-fill-color-selected: var(
                    --map-card-predefined-rectangle-fill-color-selected,
                    rgba(255, 255, 255, 0.2)
                );
                --map-card-internal-predefined-rectangle-line-segment-line: var(
                    --map-card-predefined-rectangle-line-segment-line,
                    10px
                );
                --map-card-internal-predefined-rectangle-line-segment-gap: var(
                    --map-card-predefined-rectangle-line-segment-gap,
                    5px
                );
                --map-card-internal-predefined-rectangle-icon-wrapper-size: var(
                    --map-card-predefined-rectangle-icon-wrapper-size,
                    36px
                );
                --map-card-internal-predefined-rectangle-icon-size: var(
                    --map-card-predefined-rectangle-icon-size,
                    24px
                );
                --map-card-internal-predefined-rectangle-icon-color: var(
                    --map-card-predefined-rectangle-icon-color,
                    var(--map-card-internal-secondary-text-color)
                );
                --map-card-internal-predefined-rectangle-icon-color-selected: var(
                    --map-card-predefined-rectangle-icon-color-selected,
                    var(--map-card-internal-primary-text-color)
                );
                --map-card-internal-predefined-rectangle-icon-background-color: var(
                    --map-card-predefined-rectangle-icon-background-color,
                    var(--map-card-internal-secondary-color)
                );
                --map-card-internal-predefined-rectangle-icon-background-color-selected: var(
                    --map-card-predefined-rectangle-icon-background-color-selected,
                    var(--map-card-internal-primary-color)
                );
                --map-card-internal-predefined-rectangle-label-color: var(
                    --map-card-predefined-rectangle-label-color,
                    var(--map-card-internal-secondary-text-color)
                );
                --map-card-internal-predefined-rectangle-label-color-selected: var(
                    --map-card-predefined-rectangle-label-color-selected,
                    var(--map-card-internal-primary-text-color)
                );
                --map-card-internal-predefined-rectangle-label-font-size: var(
                    --map-card-predefined-rectangle-label-font-size,
                    12px
                );
                --map-card-internal-manual-rectangle-line-width: var(--map-card-manual-rectangle-line-width, 1px);
                --map-card-internal-manual-rectangle-line-color: var(--map-card-manual-rectangle-line-color, white);
                --map-card-internal-manual-rectangle-fill-color: var(
                    --map-card-manual-rectangle-fill-color,
                    rgba(255, 255, 255, 0.2)
                );
                --map-card-internal-manual-rectangle-line-color-selected: var(
                    --map-card-manual-rectangle-line-color-selected,
                    white
                );
                --map-card-internal-manual-rectangle-fill-color-selected: var(
                    --map-card-manual-rectangle-fill-color-selected,
                    transparent
                );
                --map-card-internal-manual-rectangle-line-segment-line: var(
                    --map-card-manual-rectangle-line-segment-line,
                    10px
                );
                --map-card-internal-manual-rectangle-line-segment-gap: var(
                    --map-card-manual-rectangle-line-segment-gap,
                    5px
                );
                --map-card-internal-manual-rectangle-description-color: var(
                    --map-card-manual-rectangle-description-color,
                    white
                );
                --map-card-internal-manual-rectangle-description-font-size: var(
                    --map-card-manual-rectangle-description-font-size,
                    12px
                );
                --map-card-internal-manual-rectangle-description-offset-x: var(
                    --map-card-manual-rectangle-description-offset-x,
                    2px
                );
                --map-card-internal-manual-rectangle-description-offset-y: var(
                    --map-card-manual-rectangle-description-offset-y,
                    -8px
                );
                --map-card-internal-manual-rectangle-delete-circle-radius: var(
                    --map-card-manual-rectangle-delete-circle-radius,
                    13px
                );
                --map-card-internal-manual-rectangle-delete-circle-line-color: var(
                    --map-card-manual-rectangle-delete-circle-line-color,
                    white
                );
                --map-card-internal-manual-rectangle-delete-circle-fill-color: var(
                    --map-card-manual-rectangle-delete-circle-fill-color,
                    var(--map-card-internal-secondary-color)
                );
                --map-card-internal-manual-rectangle-delete-circle-line-color-selected: var(
                    --map-card-manual-rectangle-delete-circle-line-color-selected,
                    white
                );
                --map-card-internal-manual-rectangle-delete-circle-fill-color-selected: var(
                    --map-card-manual-rectangle-delete-circle-fill-color-selected,
                    var(--map-card-internal-primary-color)
                );
                --map-card-internal-manual-rectangle-delete-circle-line-width: var(
                    --map-card-manual-rectangle-delete-circle-line-width,
                    1px
                );
                --map-card-internal-manual-rectangle-delete-icon-color: var(
                    --map-card-manual-rectangle-delete-icon-color,
                    var(--map-card-internal-secondary-text-color)
                );
                --map-card-internal-manual-rectangle-delete-icon-color-selected: var(
                    --map-card-manual-rectangle-delete-icon-color-selected,
                    var(--map-card-internal-primary-text-color)
                );
                --map-card-internal-manual-rectangle-resize-circle-radius: var(
                    --map-card-manual-rectangle-resize-circle-radius,
                    13px
                );
                --map-card-internal-manual-rectangle-resize-circle-line-color: var(
                    --map-card-manual-rectangle-resize-circle-line-color,
                    white
                );
                --map-card-internal-manual-rectangle-resize-circle-fill-color: var(
                    --map-card-manual-rectangle-resize-circle-fill-color,
                    var(--map-card-internal-secondary-color)
                );
                --map-card-internal-manual-rectangle-resize-circle-line-color-selected: var(
                    --map-card-manual-rectangle-resize-circle-line-color-selected,
                    white
                );
                --map-card-internal-manual-rectangle-resize-circle-fill-color-selected: var(
                    --map-card-manual-rectangle-resize-circle-fill-color-selected,
                    var(--map-card-internal-primary-color)
                );
                --map-card-internal-manual-rectangle-resize-circle-line-width: var(
                    --map-card-manual-rectangle-resize-circle-line-width,
                    1px
                );
                --map-card-internal-manual-rectangle-resize-icon-color: var(
                    --map-card-manual-rectangle-resize-icon-color,
                    var(--map-card-internal-secondary-text-color)
                );
                --map-card-internal-manual-rectangle-resize-icon-color-selected: var(
                    --map-card-manual-rectangle-resize-icon-color-selected,
                    var(--map-card-internal-primary-text-color)
                );
                --map-card-internal-room-label-color: var(--map-card-room-label-color, #333);
                --map-card-internal-room-label-font-size: var(--map-card-room-label-font-size, 12px);
                --map-card-internal-transitions-duration: var(--map-card-transitions-duration, 200ms);
            }

            /* Responsive: small cards (< 350px) */
            @container vacuum-card (max-width: 349px) {
                ha-card {
                    --dvc-header-section-padding: 8px 10px 4px;
                    --dvc-header-name-size: 15px;
                    --dvc-header-status-size: 12px;
                    --dvc-stats-gap: 14px;
                    --dvc-stats-padding: 6px 10px;
                    --dvc-stat-gap: 4px;
                    --dvc-stat-font-size: 11px;
                    --dvc-stat-icon-size: 15px;
                    --dvc-action-host-padding: 6px 10px 12px;
                    --dvc-action-gap: 8px;
                    --dvc-action-btn-padding: 10px;
                    --dvc-action-font-size: 13px;
                    --dvc-action-icon-gap: 6px;
                    --dvc-action-icon-size: 18px;
                    --dvc-tab-padding: 8px 0;
                    --dvc-tab-font-size: 12px;
                    --dvc-tab-gap: 2px;
                    --dvc-tab-icon-size: 18px;
                    --dvc-chip-host-padding: 2px 10px;
                    --dvc-chip-gap: 6px;
                    --dvc-chip-padding: 8px 12px;
                    --dvc-chip-font-size: 12px;
                    --dvc-progress-host-padding: 0 10px 2px;
                    --dvc-progress-font-size: 11px;
                }
                .map-wrapper {
                    padding-top: 56px;
                }
                .controls-wrapper {
                    margin: 10px;
                    gap: 8px;
                }
                .map-actions-item {
                    width: 42px;
                    height: 42px;
                }
                .icon-on-map {
                    width: 30px;
                    height: 30px;
                }
                .standalone-icon-on-map {
                    width: 30px;
                    height: 30px;
                }
                .cycle-counter {
                    font-size: 12px;
                }
                .updating-badge {
                    font-size: 11px;
                    padding: 4px 8px;
                }
            }

            /* Responsive: large cards (> 500px) */
            @container vacuum-card (min-width: 501px) {
                ha-card {
                    --dvc-header-section-padding: 16px 20px 10px;
                    --dvc-header-name-size: 20px;
                    --dvc-stats-gap: 28px;
                    --dvc-action-host-padding: 10px 20px 20px;
                    --dvc-action-gap: 14px;
                    --dvc-action-btn-padding: 16px;
                }
                .map-wrapper {
                    padding-top: 80px;
                }
                .controls-wrapper {
                    margin: 20px;
                    gap: 14px;
                }
                .map-actions-item {
                    width: 56px;
                    height: 56px;
                }
                .icon-on-map {
                    width: 40px;
                    height: 40px;
                }
                .standalone-icon-on-map {
                    width: 40px;
                    height: 40px;
                }
            }

            .clickable {
                cursor: pointer;
            }

            .map-wrapper {
                position: relative;
                height: max-content;
                padding-top: 70px;
            }

            .map-container {
                position: relative;
            }

            #map-zoomer {
                overflow: hidden;
                display: block;
                --scale: 1;
                --x: 0;
                --y: 0;
                background: var(--map-card-internal-zoomer-background);
            }

            #map-zoomer-content {
                transform: translate(var(--x), var(--y)) scale(var(--scale));
                transform-origin: 0 0;
                position: relative;
            }

            #map-image {
                width: 100%;
                margin-bottom: -6px;
                pointer-events: none;
            }

            #map-image.zoomed {
                image-rendering: pixelated;
            }

            #room-selection-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 1;
                pointer-events: none;
                transition: opacity 0.3s ease;
            }

            #map-image-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 2;
            }

            .standalone-icon-on-map {
                background-color: var(--map-card-internal-secondary-color);
                color: var(--map-card-internal-secondary-text-color);
                border-radius: var(--map-card-internal-small-radius);
                margin: 5px;
                width: 36px;
                height: 36px;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            .map-zoom-icons {
                right: 0;
                bottom: 0;
                position: absolute;
                display: flex;
                flex-direction: column-reverse;
                background-color: var(--map-card-internal-secondary-color);
                color: var(--map-card-internal-secondary-text-color);
                border-radius: var(--map-card-internal-small-radius);
                margin: 5px;
                direction: ltr;
            }

            .map-return-base-button {
                left: 0;
                bottom: 0;
                position: absolute;
                display: inline-flex;
                background-color: var(--map-card-internal-secondary-color);
                color: var(--map-card-internal-secondary-text-color);
                border-radius: var(--map-card-internal-small-radius);
                margin: 5px;
                direction: ltr;
            }

            .updating-badge {
                top: 0;
                right: 0;
                position: absolute;
                display: inline-flex;
                align-items: center;
                gap: 6px;
                background-color: rgba(var(--rgb-warning-color, 255, 152, 0), 0.9);
                color: var(--text-primary-color, #ffffff);
                border-radius: var(--map-card-internal-small-radius);
                padding: 6px 12px;
                margin: 5px;
                font-size: 12px;
                font-weight: 500;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
                animation: pulse-opacity 2s ease-in-out infinite;
            }

            .updating-icon {
                height: 18px;
                width: 18px;
                animation: spin 2s linear infinite;
            }

            @keyframes pulse-opacity {
                0%,
                100% {
                    opacity: 0.9;
                }
                50% {
                    opacity: 0.7;
                }
            }

            @keyframes spin {
                from {
                    transform: rotate(0deg);
                }
                to {
                    transform: rotate(360deg);
                }
            }

            .map-zoom-icons-main {
                display: inline-flex;
                border-radius: var(--map-card-internal-small-radius);
                background-color: var(--map-card-internal-primary-color);
                color: var(--map-card-internal-primary-text-color);
            }

            .icon-on-map {
                touch-action: auto;
                pointer-events: auto;
                height: 36px;
                width: 36px;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            .cycle-counter {
                font-size: 14px;
                font-weight: 700;
                font-family: inherit;
                user-select: none;
            }

            .icon-on-map.zone-action {
                background-color: var(--map-card-internal-primary-color);
                color: var(--map-card-internal-primary-text-color);
                border-radius: var(--map-card-internal-small-radius);
            }

            .controls-wrapper {
                margin: 15px;
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .map-controls {
                width: 100%;
                display: inline-flex;
                gap: 10px;
                place-content: space-between;
                flex-wrap: wrap;
            }

            .map-actions-list {
                border-radius: var(--map-card-internal-big-radius);
                overflow: hidden;
                background-color: var(--map-card-internal-secondary-color);
                color: var(--map-card-internal-secondary-text-color);
                margin-inline-start: auto;
                display: inline-flex;
                height: min-content;
            }

            .map-actions-item.main {
                border-radius: var(--map-card-internal-big-radius);
                background-color: var(--map-card-internal-primary-color);
                color: var(--map-card-internal-primary-text-color);
            }

            .map-actions-item {
                width: 50px;
                height: 50px;
                display: flex;
                justify-content: center;
                align-items: center;
                background-color: transparent;
            }

            .ripple {
                position: relative;
                overflow: hidden;
                transform: translate3d(0, 0, 0);
            }

            .ripple:after {
                content: "";
                display: block;
                position: absolute;
                border-radius: 50%;
                width: 100%;
                height: 100%;
                top: 0;
                left: 0;
                pointer-events: none;
                background-image: radial-gradient(circle, var(--map-card-internal-ripple-color) 2%, transparent 10.01%);
                background-repeat: no-repeat;
                background-position: 50%;
                transform: scale(10, 10);
                opacity: 0;
                transition:
                    transform 0.5s,
                    opacity 1s;
            }

            .ripple:active:after {
                transform: scale(0, 0);
                opacity: 0.7;
                transition: 0s;
            }

            ${MapObject.styles}
            ${ManualRectangle.styles}
            ${PredefinedMultiRectangle.styles}
            ${ManualPath.styles}
            ${ManualPoint.styles}
            ${PredefinedPoint.styles}
            ${Room.styles}
            ${Obstacle.styles}
            ${Furniture.styles}
        `;
    }
}
