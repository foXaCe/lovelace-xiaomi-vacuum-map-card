/* eslint-disable @typescript-eslint/no-explicit-any */
import { css, CSSResultGroup, html, LitElement, TemplateResult } from "lit";
import { customElement, property, state } from "lit/decorators";
import { fireEvent, LovelaceCardEditor } from "custom-card-helpers";

import { RoomConfigEventData, TranslatableString, XiaomiVacuumMapCardConfig } from "./types/types";
import { localizeWithHass } from "./localize/localize";
import { PlatformGenerator } from "./model/generators/platform-generator";
import {
    EDITOR_CUSTOM_ELEMENT_NAME,
    EVENT_AUTOGENERATED_CONFIG,
    EVENT_AUTOGENERATED_CONFIG_GET,
    EVENT_ROOM_CONFIG,
    EVENT_ROOM_CONFIG_GET,
    EVENT_SELECTION_CHANGED,
    EVENT_SERVICE_CALL,
    EVENT_SERVICE_CALL_GET,
} from "./const";
import { copyMessage } from "./utils";
import { ToastRenderer } from "./renderers/toast-renderer";
import { HomeAssistantFixed } from "./types/fixes";

@customElement(EDITOR_CUSTOM_ELEMENT_NAME)
export class XiaomiVacuumMapCardEditor extends LitElement implements Omit<LovelaceCardEditor, "hass"> {
    @property({ attribute: false }) public hass?: HomeAssistantFixed;
    @state() private _config?: XiaomiVacuumMapCardConfig;
    @state() private _helpers?: any;
    @state() private _lastSelection?: any;
    @state() private _tilesExpanded = false;
    @state() private _generatedTiles: any[] = [];
    private _initialized = false;

    constructor() {
        super();
        this._handleNewSelection = this._handleNewSelection.bind(this);
        this._handleAutogeneratedConfig = this._handleAutogeneratedConfig.bind(this);
        this._handleRoomConfig = this._handleRoomConfig.bind(this);
        this._handleServiceCall = this._handleServiceCall.bind(this);
    }

    get _title(): string {
        return this._config?.title || "";
    }

    get _entity(): string {
        return this._config?.entity || "";
    }

    get _vacuum_platform(): string {
        return PlatformGenerator.getPlatformName(this._config?.vacuum_platform);
    }

    get _camera(): string {
        return this._config?.map_source?.camera || "";
    }

    get _map_locked(): boolean {
        return this._config?.map_locked || false;
    }

    get _two_finger_pan(): boolean {
        return this._config?.two_finger_pan || false;
    }

    get _map_only(): boolean {
        return this._config?.map_only || false;
    }

    get _show_tiles(): boolean {
        return this._config?.show_tiles !== false;
    }

    get _tiles_only(): boolean {
        return this._config?.tiles_only || false;
    }

    private static _copyServiceCall(): void {
        window.dispatchEvent(new Event(EVENT_SERVICE_CALL_GET));
    }

    private _setStaticConfig(): void {
        if (window.confirm(this._localize("editor.alerts.set_static_config"))) {
            window.dispatchEvent(new Event(EVENT_AUTOGENERATED_CONFIG_GET));
        }
    }

    private static _generateRoomsConfig(): void {
        window.dispatchEvent(new Event(EVENT_ROOM_CONFIG_GET));
    }

    public setConfig(config: XiaomiVacuumMapCardConfig): void {
        this._config = config;
        this.loadCardHelpers();
    }

    connectedCallback(): void {
        super.connectedCallback();
        window.addEventListener(EVENT_SELECTION_CHANGED, this._handleNewSelection);
        window.addEventListener(EVENT_AUTOGENERATED_CONFIG, this._handleAutogeneratedConfig);
        window.addEventListener(EVENT_ROOM_CONFIG, this._handleRoomConfig);
        window.addEventListener(EVENT_SERVICE_CALL, this._handleServiceCall);
    }

    disconnectedCallback(): void {
        super.disconnectedCallback();
        window.removeEventListener(EVENT_SELECTION_CHANGED, this._handleNewSelection);
        window.removeEventListener(EVENT_AUTOGENERATED_CONFIG, this._handleAutogeneratedConfig);
        window.removeEventListener(EVENT_ROOM_CONFIG, this._handleRoomConfig);
        window.removeEventListener(EVENT_SERVICE_CALL, this._handleServiceCall);
    }

    protected shouldUpdate(): boolean {
        if (!this._initialized) {
            this._initialize();
        }
        return true;
    }

    protected render(): TemplateResult | void {
        if (!this.hass || !this._helpers) {
            return html``;
        }

        this._helpers.importMoreInfoControl("climate");

        const entityIds = Object.keys(this.hass.states);
        const cameras = entityIds.filter(e => ["camera", "image"].includes(e.substr(0, e.indexOf("."))));
        const vacuums = entityIds.filter(e => e.substr(0, e.indexOf(".")) === "vacuum");

        return html`
            <div class="card-config">
                <div class="description">
                    ${this._localize("editor.description.text")}
                </div>
                <div class="values">
                    <ha-textfield
                        label="${this._localize("editor.label.name")}"
                        .value="${this._title}"
                        .configValue="${"title"}"
                        @input="${this._valueChanged}"></ha-textfield>
                </div>
                <div class="values">
                    <ha-select
                        naturalMenuWidth
                        fixedMenuPosition
                        label="${this._localize("editor.label.entity")}"
                        @selected="${this._valueChanged}"
                        @closed="${ev => ev.stopPropagation()}"
                        .configValue="${"entity"}"
                        .value="${this._entity}">
                        ${vacuums.map(entity => {
                            return html` <mwc-list-item .value="${entity}">${entity}</mwc-list-item> `;
                        })}
                    </ha-select>
                </div>
                <div class="values">
                    <ha-select
                        naturalMenuWidth
                        fixedMenuPosition
                        label="${this._localize("editor.label.camera")}"
                        @selected="${this._cameraChanged}"
                        @closed="${ev => ev.stopPropagation()}"
                        .configValue="${"camera"}"
                        .value="${this._camera}">
                        ${cameras.map(entity => {
                            return html` <mwc-list-item .value="${entity}">${entity}</mwc-list-item> `;
                        })}
                    </ha-select>
                </div>
                <div class="values">
                    <ha-formfield class="switch-wrapper" .label="${this._localize("editor.label.map_locked")}">
                        <ha-switch
                            .checked="${this._map_locked}"
                            .configValue="${"map_locked"}"
                            @change="${this._valueChanged}"></ha-switch>
                    </ha-formfield>
                </div>
                <div class="values">
                    <ha-formfield class="switch-wrapper" .label="${this._localize("editor.label.two_finger_pan")}">
                        <ha-switch
                            .checked="${this._two_finger_pan}"
                            .configValue="${"two_finger_pan"}"
                            @change="${this._valueChanged}"></ha-switch>
                    </ha-formfield>
                </div>
                <div class="values">
                    <ha-formfield class="switch-wrapper" .label="${this._localize("editor.label.map_only")}">
                        <ha-switch
                            .checked="${this._map_only}"
                            .configValue="${"map_only"}"
                            @change="${this._mapOnlyChanged}"></ha-switch>
                    </ha-formfield>
                </div>
                <div class="values">
                    <ha-formfield class="switch-wrapper" .label="${this._localize("editor.label.show_tiles")}">
                        <ha-switch
                            .checked="${this._show_tiles}"
                            .configValue="${"show_tiles"}"
                            @change="${this._valueChanged}"></ha-switch>
                    </ha-formfield>
                </div>
                <div class="values">
                    <ha-formfield class="switch-wrapper" .label="${this._localize("editor.label.tiles_only")}">
                        <ha-switch
                            .checked="${this._tiles_only}"
                            .configValue="${"tiles_only"}"
                            @change="${this._tilesOnlyChanged}"></ha-switch>
                    </ha-formfield>
                </div>
                ${this._tiles_only ? this._renderTilesConfig() : html``}
                ${ToastRenderer.render("editor")}
            </div>
        `;
    }

    private _initialize(): void {
        if (this.hass === undefined) return;
        if (this._config === undefined) return;
        if (this._helpers === undefined) return;
        this._initialized = true;
    }

    private async loadCardHelpers(): Promise<void> {
        this._helpers = await (window as any).loadCardHelpers();
    }

    private _handleNewSelection(e: Event): void {
        this._lastSelection = JSON.stringify((e as any).selection).replaceAll(",", ", ");
    }

    private _handleAutogeneratedConfig(e: Event): void {
        const config = (e as any).presetConfig as XiaomiVacuumMapCardConfig;
        this._generatedTiles = config.tiles || [];
        this._showToast("editor.label.config_set", "mdi:check", true);
        this._setConfig(config);
    }

    private _handleRoomConfig(e: Event): void {
        const roomsTemplate = PlatformGenerator.getRoomsTemplate(this._vacuum_platform);
        const roomConfig = (e as any).roomConfig as RoomConfigEventData;
        if (!roomConfig) {
            this._showToast("editor.label.config_set_failed", "mdi:close", false);
            return;
        }
        const map_modes = this._config?.map_modes ?? [];
        if (map_modes.length !== 0 && (roomConfig.modeIndex ?? -1) >= 0) {
            map_modes[roomConfig.modeIndex ?? -1] = {
                ...map_modes[roomConfig.modeIndex ?? -1],
                predefined_selections: roomConfig.rooms,
            };
        } else {
            if (map_modes.length === 0) {
                map_modes.push(...PlatformGenerator.generateDefaultModes(this._vacuum_platform));
            }
            if (roomsTemplate) {
                map_modes.push({
                    template: roomsTemplate,
                    predefined_selections: roomConfig.rooms,
                });
            }
        }
        if (this._config) {
            this._setConfig({ ...this._config, map_modes: map_modes });
        }
        this._showToast("editor.label.config_set", "mdi:check", true);
    }

    private _handleServiceCall(e: Event): void {
        const serviceCall = (e as any).serviceCall as string;
        copyMessage(serviceCall ?? "");
        this._showToast("editor.label.copied", "mdi:content-copy", true);
    }

    private _copySelection(): void {
        copyMessage(this._lastSelection ?? []);
        this._showToast("editor.label.copied", "mdi:content-copy", true);
    }

    private _showToast(text: string, icon: string, successful: boolean, additionalText = ""): void {
        ToastRenderer.showToast(
            this.shadowRoot,
            v => this._localize(v),
            "editor",
            text,
            icon,
            successful,
            additionalText,
        );
    }

    private _platformChanged(ev): void{
        if (!this._config || !this.hass) {
            return;
        }
        const value = ev.target.value;
        if (this._vacuum_platform === value) return;
        const tmpConfig = { ...this._config };
        tmpConfig["vacuum_platform"] = value;
        if (PlatformGenerator.getCalibration(tmpConfig.vacuum_platform)) {
            if (tmpConfig["calibration_source"] && tmpConfig["calibration_source"]["camera"]) {
                delete tmpConfig["calibration_source"];
            }
        } else {
            if (!tmpConfig["calibration_source"]
                && tmpConfig["map_source"]
                && tmpConfig["map_source"]["camera"]
            ) {
                tmpConfig["calibration_source"] = { camera: true };
            }
        }
        this._config = tmpConfig;
        fireEvent(this, "config-changed", { config: this._config });

    }

    private _cameraChanged(ev): void {
        if (!this._config || !this.hass) {
            return;
        }
        const value = ev.target.value;
        if (this._camera === value) return;
        const tmpConfig = { ...this._config };
        tmpConfig["map_source"] = { camera: value };
        if (!PlatformGenerator.getCalibration(this._config.vacuum_platform)
            && !tmpConfig["calibration_source"]
            && "calibration_points" in this.hass.states[value].attributes
        ) {
            tmpConfig["calibration_source"] = { camera: true };
        }
        this._config = tmpConfig;
        fireEvent(this, "config-changed", { config: this._config });
    }

    private _mapOnlyChanged(ev): void {
        if (!this._config || !this.hass) {
            return;
        }
        const checked = ev.target.checked;
        this._config = {
            ...this._config,
            map_only: checked,
            tiles_only: checked ? false : this._config.tiles_only, // Désactiver tiles_only si map_only est activé
        };
        fireEvent(this, "config-changed", { config: this._config });
    }

    private _tilesOnlyChanged(ev): void {
        if (!this._config || !this.hass) {
            return;
        }
        const checked = ev.target.checked;
        this._config = {
            ...this._config,
            tiles_only: checked,
            map_only: checked ? false : this._config.map_only, // Désactiver map_only si tiles_only est activé
        };
        fireEvent(this, "config-changed", { config: this._config });

        // Si activé, charger les tuiles générées automatiquement
        if (checked && this._generatedTiles.length === 0) {
            window.dispatchEvent(new Event(EVENT_AUTOGENERATED_CONFIG_GET));
        }
    }

    private _valueChanged(ev): void {
        if (!this._config || !this.hass) {
            return;
        }
        const target = ev.target;
        if (this[`_${target.configValue}`] === target.value) {
            return;
        }
        if (!target.configValue) {
            const tmpConfig: XiaomiVacuumMapCardConfig = { ...this._config };
            delete tmpConfig[target.configValue];
            this._config = tmpConfig;
        } else {
            this._config = {
                ...this._config,
                [target.configValue]: target.checked !== undefined ? target.checked : target.value,
            };
        }
        fireEvent(this, "config-changed", { config: this._config });
    }

    private _tileVisibilityChanged(tileId: string, visible: boolean): void {
        if (!this._config) return;

        const tiles = this._config.tiles || this._generatedTiles.map(t => ({ ...t }));
        const tileIndex = tiles.findIndex(t => t.tile_id === tileId);

        if (tileIndex >= 0) {
            tiles[tileIndex] = { ...tiles[tileIndex], visible };
        } else {
            const generatedTile = this._generatedTiles.find(t => t.tile_id === tileId);
            if (generatedTile) {
                tiles.push({ ...generatedTile, visible });
            }
        }

        this._config = {
            ...this._config,
            tiles: tiles,
        };
        fireEvent(this, "config-changed", { config: this._config });
    }

    private _renderTilesConfig(): TemplateResult {
        if (this._generatedTiles.length === 0) {
            return html`
                <div class="values">
                    <div style="padding: 16px; color: var(--secondary-text-color);">
                        ${this._localize("editor.label.tiles_loading") || "Loading tiles..."}
                    </div>
                </div>
            `;
        }

        const configTiles = this._config?.tiles || [];

        return html`
            <div class="tiles-config-wrapper">
                <div class="tiles-header" @click="${() => this._tilesExpanded = !this._tilesExpanded}">
                    <ha-icon icon="${this._tilesExpanded ? 'mdi:chevron-down' : 'mdi:chevron-right'}"></ha-icon>
                    <span>${this._localize("editor.label.configure_tiles") || "Configure tiles"}</span>
                </div>
                ${this._tilesExpanded ? html`
                    <div class="tiles-list">
                        ${this._generatedTiles.map(tile => {
                            const configTile = configTiles.find(t => t.tile_id === tile.tile_id);
                            const isVisible = configTile?.visible !== undefined ? configTile.visible : true;

                            return html`
                                <div class="tile-item">
                                    <ha-formfield .label="${tile.label || tile.tile_id}">
                                        <ha-switch
                                            .checked="${isVisible}"
                                            @change="${(ev) => this._tileVisibilityChanged(tile.tile_id, ev.target.checked)}">
                                        </ha-switch>
                                    </ha-formfield>
                                </div>
                            `;
                        })}
                    </div>
                ` : html``}
            </div>
        `;
    }

    private _setConfig(config: XiaomiVacuumMapCardConfig): void {
        this._config = { ...config };
        fireEvent(this, "config-changed", { config: this._config });
    }

    private _localize(ts: TranslatableString): string {
        return localizeWithHass(ts, this.hass);
    }

    static get styles(): CSSResultGroup {
        return css`
            .card-config {
                position: relative;
                --map-card-internal-toast-successful-icon-color: var(
                    --map-card-toast-successful-icon-color,
                    rgb(0, 255, 0)
                );
                --map-card-internal-toast-unsuccessful-icon-color: var(
                    --map-card-toast-unsuccessful-icon-color,
                    rgb(255, 0, 0)
                );
                --map-card-internal-small-radius: var(--map-card-small-radius, 18px);
                --map-card-internal-primary-color: var(--map-card-primary-color, var(--slider-color));
                padding-bottom: 15px;
            }

            .values {
                padding-left: 16px;
                margin: 8px;
                display: grid;
            }

            .switch-wrapper {
                padding: 8px;
            }

            .selection-controls-wrapper {
                display: flex;
                align-content: stretch;
                justify-content: space-between;
                align-items: center;
            }

            .config-buttons-wrapper {
                display: flex;
                flex-wrap: wrap;
                align-items: center;
                gap: 20px;
            }

            .tiles-config-wrapper {
                margin: 8px 16px;
                border: 1px solid var(--divider-color);
                border-radius: 8px;
                overflow: hidden;
            }

            .tiles-header {
                display: flex;
                align-items: center;
                padding: 12px 16px;
                cursor: pointer;
                background: var(--secondary-background-color);
                gap: 8px;
                font-weight: 500;
            }

            .tiles-header:hover {
                background: var(--divider-color);
            }

            .tiles-list {
                padding: 8px 0;
            }

            .tile-item {
                padding: 4px 16px 4px 40px;
            }

            .tile-item ha-formfield {
                width: 100%;
                padding: 8px;
            }

            .selection-text {
                flex-grow: 1;
                padding: 10px;
            }

            .separated {
                border-top: solid 1px;
                border-top-color: var(--primary-text-color);
            }
          
            .version {
                position: absolute;
                bottom: 0;
                right: 0;
                opacity: 30%;
            }

            ${ToastRenderer.styles}
        `;
    }
}
